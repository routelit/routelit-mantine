import datetime
from typing import Any, Callable, ClassVar, Literal, Optional, TypedDict, Union, cast

from routelit import AssetTarget, RouteLitBuilder
from routelit.domain import RLOption, RouteLitElement


class GroupOption(TypedDict):
    group: str
    items: list[str]


class MTTab(TypedDict, total=False):
    value: str
    label: Optional[str]
    color: Optional[str]
    left_section: Optional[RouteLitElement]
    right_section: Optional[RouteLitElement]
    size: Optional[Union[str, int]]
    keep_mounted: Optional[bool]
    children: Optional[str]  # For internal use
    leftSection: Optional[RouteLitElement]  # For internal use
    rightSection: Optional[RouteLitElement]  # For internal use


class RLBuilder(RouteLitBuilder):
    """
    A builder for a RouteLit application.
    This Builder template serves as example on how to create a RouteLit custom components.
    """

    static_assets_targets: ClassVar[list[AssetTarget]] = [
        {
            "package_name": "routelit_mantine",
            "path": "static",
        }
    ]

    def _init_root(self) -> "RLBuilder":
        new_element = self._create_element(
            name="provider",
            key="provider",
            props={
                # "forceColorScheme": "dark",
                "defaultColorScheme": "auto",
                "theme": {
                    # "primaryColor": "orange",
                },
            },
            virtual=True,
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def _init_app_shell(self) -> "RLBuilder":
        new_element = self._create_element(
            name="appshell",
            key="__appshell__",
            props={},
            virtual=True,
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def _init_navbar(self) -> "RLBuilder":
        new_element = self._create_element(
            name="navbar",
            key="__navbar__",
            props={},
            virtual=True,
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def _init_main(self) -> "RLBuilder":
        new_element = self._create_element(
            name="main",
            key="__main__",
            props={},
            virtual=True,
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def _on_init(self) -> None:
        self._root = self._init_root()
        with self._root:
            self._app_shell = self._init_app_shell()
            with self._app_shell:
                self._navbar = self._init_navbar()
                self._main = self._init_main()
        self._parent_element = self._main._parent_element
        self.active_child_builder = self._main

    def set_provider_props(self, theme: dict[str, Any], **kwargs: Any) -> None:
        self._root.root_element.props.update(kwargs)
        self._root.root_element.props["theme"] = theme

    @property
    def sidebar(self) -> "RLBuilder":
        return self._navbar

    def container(  # type: ignore[override]
        self, *, fluid: bool = False, key: Optional[str] = None, size: Optional[str] = None, **kwargs: Any
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("container"),
            name="container",
            props={"fluid": fluid, "size": size, **kwargs},
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def flex(  # type: ignore[override]
        self,
        *,
        align: Optional[str] = None,
        column_gap: Optional[str] = None,
        direction: Optional[str] = None,
        gap: Optional[str] = None,
        justify: Optional[str] = None,
        key: Optional[str] = None,
        row_gap: Optional[str] = None,
        wrap: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("flex"),
            name="flex",
            props={
                "align": align,
                "columnGap": column_gap,
                "direction": direction,
                "gap": gap,
                "justify": justify,
                "rowGap": row_gap,
                "wrap": wrap,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def grid(
        self,
        *,
        align: Optional[str] = None,
        breakpoints: Optional[dict] = None,
        columns: Optional[int] = None,
        grow: Optional[bool] = None,
        gutter: Optional[dict] = None,
        justify: Optional[str] = None,
        key: Optional[str] = None,
        overflow: Optional[str] = None,
        query_type: Optional[Literal["media", "container"]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("grid"),
            name="grid",
            props={
                "align": align,
                "breakpoints": breakpoints,
                "columns": columns,
                "grow": grow,
                "gutter": gutter,
                "justify": justify,
                "overflow": overflow,
                "type": query_type,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def grid_col(
        self,
        *,
        key: Optional[str] = None,
        offset: Optional[int] = None,
        order: Optional[int] = None,
        span: Optional[int] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("gridcol"),
            name="gridcol",
            props={
                "offset": offset,
                "order": order,
                "span": span,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def group(
        self,
        *,
        align: Optional[str] = None,
        gap: Optional[str] = None,
        grow: Optional[bool] = None,
        justify: Optional[str] = None,
        key: Optional[str] = None,
        prevent_grow_overflow: Optional[bool] = None,
        wrap: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("group"),
            name="group",
            props={
                "align": align,
                "gap": gap,
                "grow": grow,
                "justify": justify,
                "preventGrowOverflow": prevent_grow_overflow,
                "wrap": wrap,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def simple_grid(
        self,
        *,
        cols: Optional[int] = None,
        key: Optional[str] = None,
        query_type: Optional[Literal["media", "container"]] = None,
        spacing: Optional[str] = None,
        vertical_spacing: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("simplegrid"),
            name="simplegrid",
            props={
                "cols": cols,
                "spacing": spacing,
                "type": query_type,
                "verticalSpacing": vertical_spacing,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def space(
        self,
        *,
        h: Optional[str] = None,
        key: Optional[str] = None,
        v: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            key=key or self._new_text_id("space"),
            name="space",
            props={"h": h, "v": v, **kwargs},
        )

    def stack(
        self,
        *,
        align: Optional[str] = None,
        gap: Optional[str] = None,
        justify: Optional[str] = None,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        new_element = self._create_element(
            key=key or self._new_text_id("stack"),
            name="stack",
            props={
                "align": align,
                "gap": gap,
                "justify": justify,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(new_element))

    def checkbox(
        self,
        label: str,
        *,
        auto_contrast: Optional[bool] = None,
        checked: bool = False,
        color: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        icon_color: Optional[str] = None,
        key: Optional[str] = None,
        label_position: Optional[Literal["left", "right"]] = None,
        name: Optional[str] = None,
        on_change: Optional[Callable[[bool], None]] = None,
        radius: Optional[Union[Literal["xs", "sm", "md", "lg", "xl"], int]] = None,
        size: Optional[Literal["xs", "sm", "md", "lg", "xl"]] = None,
        **kwargs: Any,
    ) -> bool:
        return self._x_checkbox(
            "checkbox",
            key or self._new_widget_id("checkbox", label),
            autoContrast=auto_contrast,
            checked=checked,
            color=color,
            description=description,
            disabled=disabled,
            error=error,
            iconColor=icon_color,
            label=label,
            labelPosition=label_position,
            name=name,
            on_change=on_change,
            radius=radius,
            size=size,
            **kwargs,
        )

    def checkbox_group(  # type: ignore[override]
        self,
        label: str,
        options: list[Union[RLOption, str]],
        *,
        description: Optional[str] = None,
        error: Optional[str] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        group_props: Optional[dict[str, Any]] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[list[str]], None]] = None,
        radius: Optional[Union[str, int]] = None,
        read_only: Optional[bool] = None,
        required: Optional[bool] = None,
        size: Optional[str] = None,
        value: Optional[list[str]] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> list[str]:
        return self._x_checkbox_group(
            "checkboxgroup",
            key or self._new_widget_id("checkbox-group", label),
            description=description,
            error=error,
            format_func=format_func,
            groupProps=group_props,
            label=label,
            on_change=on_change,
            options=options,  # type: ignore[arg-type]
            radius=radius,
            readOnly=read_only,
            required=required,
            size=size,
            value=value,
            withAsterisk=with_asterisk,
            **kwargs,
        )

    def chip_group(
        self,
        key: str,
        options: list[Union[RLOption, str]],
        *,
        format_func: Optional[Callable[[Any], str]] = None,
        group_props: Optional[dict[str, Any]] = None,
        multiple: bool = False,
        on_change: Optional[Callable[[Union[str, list[str]]], None]] = None,
        value: Optional[Union[str, list[str]]] = None,
        **kwargs: Any,
    ) -> Union[str, list[str]]:
        if multiple:
            return self._x_checkbox_group(
                "chipgroup",
                key,
                format_func=format_func,
                groupProps=group_props,
                multiple=True,
                on_change=on_change,
                options=options,  # type: ignore[arg-type]
                value=value,  # type: ignore[arg-type]
                **kwargs,
            )
        return self._x_radio_select(  # type: ignore[no-any-return]
            "chipgroup",
            key,
            format_func=format_func,
            groupProps=group_props,
            multiple=False,
            on_change=on_change,
            options=options,  # type: ignore[arg-type]
            value=value,
            **kwargs,
        )

    def chip(
        self,
        label: str,
        *,
        auto_contrast: Optional[bool] = None,
        checked: bool = False,
        color: Optional[str] = None,
        disabled: Optional[bool] = None,
        icon: Optional[RouteLitElement] = None,
        input_type: Optional[Literal["checkbox", "radio"]] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[bool], None]] = None,
        radius: Optional[Union[Literal["xs", "sm", "md", "lg", "xl"], int]] = None,
        size: Optional[Literal["xs", "sm", "md", "lg", "xl"]] = None,
        **kwargs: Any,
    ) -> bool:
        return self._x_checkbox(
            "chip",
            key or self._new_widget_id("chip", label),
            autoContrast=auto_contrast,
            checked=checked,
            children=label,
            color=color,
            disabled=disabled,
            icon=icon,
            on_change=on_change,
            radius=radius,
            size=size,
            type=input_type,
            **kwargs,
        )

    def color_input(
        self,
        label: str,
        *,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        fix_on_blur: Optional[bool] = None,
        input_size: Optional[str] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[str], None]] = None,
        radius: Optional[str] = None,
        required: Optional[bool] = None,
        size: Optional[str] = None,
        swatches: Optional[list[str]] = None,
        value: Optional[str] = None,
        with_asterisk: Optional[bool] = None,
        with_picker: Optional[bool] = None,
        with_preview: Optional[bool] = None,
        **kwargs: Any,
    ) -> str:
        return self._x_input(  # type: ignore[return-value]
            "colorinput",
            key or self._new_widget_id("colorinput", label),
            description=description,
            disabled=disabled,
            error=error,
            fixOnBlur=fix_on_blur,
            inputSize=input_size,
            label=label,
            on_change=on_change,
            radius=radius,
            required=required,
            size=size,
            swatches=swatches,
            value=value,
            withAsterisk=with_asterisk,
            withPicker=with_picker,
            withPreview=with_preview,
            **kwargs,
        )

    def fieldset(
        self,
        legend: str,
        *,
        disabled: Optional[bool] = None,
        key: Optional[str] = None,
        radius: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        element = self._create_element(
            key=key or self._new_widget_id("fieldset", legend),
            name="fieldset",
            props={
                "disabled": disabled,
                "legend": legend,
                "radius": radius,
                **kwargs,
            },
        )
        return cast(RLBuilder, self._build_nested_builder(element))

    def text_input(
        self,
        label: str,
        *,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        key: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        on_change: Optional[Callable[[str], None]] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        value: Optional[str] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> str:
        return cast(
            str,
            self._x_input(
                "textinput",
                key or self._new_widget_id("textinput", label),
                description=description,
                disabled=disabled,
                error=error,
                label=label,
                leftSection=left_section,
                leftSectionProps=left_section_props,
                leftSectionWidth=left_section_width,
                on_change=on_change,
                required=required,
                rightSection=right_section,
                rightSectionProps=right_section_props,
                rightSectionWidth=right_section_width,
                size=size,
                value=value,
                withAsterisk=with_asterisk,
                **kwargs,
            ),
        )

    def native_select(
        self,
        label: str,
        options: list[Union[RLOption, str]],
        *,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        key: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        on_change: Optional[Callable[[str], None]] = None,
        radius: Optional[str] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        value: Optional[str] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> str:
        return cast(
            str,
            self._x_radio_select(
                "nativeselect",
                key or self._new_widget_id("native-select", label),
                description=description,
                disabled=disabled,
                error=error,
                format_func=format_func,
                label=label,
                leftSection=left_section,
                leftSectionProps=left_section_props,
                leftSectionWidth=left_section_width,
                on_change=on_change,
                options=options,  # type: ignore[arg-type]
                options_attr="data",
                radius=radius,
                required=required,
                rightSection=right_section,
                rightSectionProps=right_section_props,
                rightSectionWidth=right_section_width,
                size=size,
                value=value,
                withAsterisk=with_asterisk,
                **kwargs,
            ),
        )

    def number_input(
        self,
        label: str,
        *,
        allow_decimal: Optional[bool] = None,
        allow_leading_zeros: Optional[bool] = None,
        allow_negative: Optional[bool] = None,
        allowed_decimal_separators: Optional[list[str]] = None,
        decimal_scale: Optional[int] = None,
        decimal_separator: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        hide_controls: Optional[bool] = None,
        key: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        max_value: Optional[Union[float, int]] = None,
        min_value: Optional[Union[float, int]] = None,
        on_change: Optional[Callable[[Union[float, int]], None]] = None,
        parser: Callable[[str], Union[float, int]] = float,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        step: Optional[Union[float, int]] = None,
        value: Optional[Union[float, int]] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> Union[float, int]:
        return parser(
            cast(
                str,
                self._x_input(
                    "numberinput",
                    key or self._new_widget_id("numberinput", label),
                    allowDecimal=allow_decimal,
                    allowLeadingZeros=allow_leading_zeros,
                    allowNegative=allow_negative,
                    allowedDecimalSeparators=allowed_decimal_separators,
                    decimalScale=decimal_scale,
                    decimalSeparator=decimal_separator,
                    description=description,
                    disabled=disabled,
                    error=error,
                    hideControls=hide_controls,
                    label=label,
                    leftSection=left_section,
                    leftSectionProps=left_section_props,
                    leftSectionWidth=left_section_width,
                    max=max_value,
                    min=min_value,
                    on_change=on_change,
                    required=required,
                    rightSection=right_section,
                    rightSectionProps=right_section_props,
                    rightSectionWidth=right_section_width,
                    size=size,
                    step=step,
                    value=value,
                    withAsterisk=with_asterisk,
                    **kwargs,
                ),
            )
        )

    def password_input(
        self,
        label: str,
        *,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        input_size: Optional[str] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[str], None]] = None,
        radius: Optional[str] = None,
        required: Optional[bool] = None,
        size: Optional[str] = None,
        value: Optional[str] = None,
        visible: Optional[bool] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        return self._x_input(
            "passwordinput",
            key or self._new_widget_id("passwordinput", label),
            description=description,
            disabled=disabled,
            error=error,
            inputSize=input_size,
            label=label,
            on_change=on_change,
            radius=radius,
            required=required,
            size=size,
            value=value,
            visible=visible,
            withAsterisk=with_asterisk,
            **kwargs,
        )

    def radio_group(
        self,
        label: str,
        options: list[Union[RLOption, str]],
        *,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        group_props: Optional[dict[str, Any]] = None,
        input_size: Optional[str] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[str], None]] = None,
        read_only: Optional[bool] = None,
        required: Optional[bool] = None,
        size: Optional[str] = None,
        value: Optional[str] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        return cast(
            Optional[str],
            self._x_radio_select(
                "radiogroup",
                key or self._new_widget_id("radio-group", label),
                description=description,
                disabled=disabled,
                error=error,
                format_func=format_func,
                group_props=group_props,
                inputSize=input_size,
                label=label,
                on_change=on_change,
                options=options,  # type: ignore[arg-type]
                readOnly=read_only,
                required=required,
                size=size,
                value=value,
                withAsterisk=with_asterisk,
                **kwargs,
            ),
        )

    def range_slider(
        self,
        label: str,
        *,
        color: Optional[str] = None,
        disabled: Optional[bool] = None,
        inverted: Optional[bool] = None,
        key: Optional[str] = None,
        label_always_on: Optional[bool] = None,
        marks: Optional[list[RLOption]] = None,
        max_range: Optional[float] = None,
        max_value: Optional[float] = None,
        min_value: Optional[float] = None,
        on_change: Optional[Callable[[tuple[float, float]], None]] = None,
        precision: Optional[int] = None,
        step: Optional[float] = None,
        value: Optional[tuple[float, float]] = None,
        **kwargs: Any,
    ) -> tuple[float, float]:
        return cast(
            tuple[float, float],
            self._x_input(
                "rangeslider",
                key or self._new_widget_id("rangeslider", label),
                color=color,
                disabled=disabled,
                inverted=inverted,
                label=label,
                labelAlwaysOn=label_always_on,
                marks=marks,
                max=max_value,
                maxRange=max_range,
                min=min_value,
                on_change=on_change,
                precision=precision,
                step=step,
                value=value,
                **kwargs,
            ),
        )

    def rating(
        self,
        key: str,
        *,
        color: Optional[str] = None,
        count: Optional[int] = None,
        fractions: Optional[int] = None,
        on_change: Optional[Callable[[int], None]] = None,
        read_only: Optional[bool] = None,
        size: Optional[str] = None,
        parser: Callable[[Any], Union[float, int]] = float,
        value: Optional[int] = None,
        **kwargs: Any,
    ) -> float:
        return parser(
            self._x_input(
                "rating",
                key,
                color=color,
                count=count,
                fractions=fractions,
                on_change=on_change,
                readOnly=read_only,
                size=size,
                value=value,
                **kwargs,
            )
        )

    def segmented_control(
        self,
        key: str,
        options: list[Union[RLOption, str]],
        *,
        auto_contrast: Optional[bool] = None,
        color: Optional[str] = None,
        disabled: Optional[bool] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        full_width: Optional[bool] = None,
        on_change: Optional[Callable[[str], None]] = None,
        orientation: Optional[Literal["horizontal", "vertical"]] = None,
        radius: Optional[str] = None,
        read_only: Optional[bool] = None,
        size: Optional[str] = None,
        transition_duration: Optional[int] = None,
        value: Optional[str] = None,
        with_items_borders: Optional[bool] = None,
        **kwargs: Any,
    ) -> str:
        value = self._x_radio_select(
            "segmentedcontrol",
            key,
            autoContrast=auto_contrast,
            color=color,
            disabled=disabled,
            format_func=format_func,
            fullWidth=full_width,
            on_change=on_change,
            options=options,  # type: ignore[arg-type]
            options_attr="data",
            orientation=orientation,
            radius=radius,
            readOnly=read_only,
            size=size,
            transitionDuration=transition_duration,
            value=value,
            withItemsBorders=with_items_borders,
            **kwargs,
        )
        if value is None and options and len(options) > 0:
            return options[0]["value"] if isinstance(options[0], dict) else options[0]
        return value

    def slider(
        self,
        label: str,
        *,
        disabled: Optional[bool] = None,
        inverted: Optional[bool] = None,
        key: Optional[str] = None,
        label_always_on: Optional[bool] = None,
        marks: Optional[list[RLOption]] = None,
        max_value: Optional[float] = None,
        min_value: Optional[float] = None,
        on_change: Optional[Callable[[float], None]] = None,
        precision: Optional[int] = None,
        restrict_to_marks: Optional[bool] = None,
        show_label_on_hover: Optional[bool] = None,
        size: Optional[str] = None,
        step: Optional[float] = None,
        parser: Callable[[Any], Union[float, int]] = float,
        thumb_label: Optional[str] = None,
        thumb_size: Optional[str] = None,
        value: Optional[float] = None,
        **kwargs: Any,
    ) -> Union[float, int]:
        return parser(
            self._x_input(
                "slider",
                key or self._new_widget_id("slider", label),
                disabled=disabled,
                inverted=inverted,
                label=label,
                labelAlwaysOn=label_always_on,
                marks=marks,
                max=max_value,
                min=min_value,
                on_change=on_change,
                precision=precision,
                restrictToMarks=restrict_to_marks,
                showLabelOnHover=show_label_on_hover,
                size=size,
                step=step,
                thumbLabel=thumb_label,
                thumbSize=thumb_size,
                value=value,
                **kwargs,
            )
        )

    def switch(
        self,
        label: str,
        *,
        checked: bool = False,
        color: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        key: Optional[str] = None,
        label_position: Optional[Literal["left", "right"]] = None,
        on_change: Optional[Callable[[bool], None]] = None,
        radius: Optional[str] = None,
        size: Optional[str] = None,
        thumb_icon: Optional[RouteLitElement] = None,
        with_thumb_indicator: Optional[bool] = None,
        **kwargs: Any,
    ) -> bool:
        return self._x_checkbox(
            "switch",
            key or self._new_widget_id("switch", label),
            checked=checked,
            color=color,
            description=description,
            disabled=disabled,
            error=error,
            label=label,
            labelPosition=label_position,
            on_change=on_change,
            radius=radius,
            size=size,
            thumbIcon=thumb_icon,
            withThumbIndicator=with_thumb_indicator,
            **kwargs,
        )

    def switch_group(
        self,
        label: str,
        options: list[Union[RLOption, str]],
        *,
        description: Optional[str] = None,
        error: Optional[str] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        group_props: Optional[dict[str, Any]] = None,
        key: Optional[str] = None,
        on_change: Optional[Callable[[list[str]], None]] = None,
        read_only: Optional[bool] = None,
        required: Optional[bool] = None,
        size: Optional[str] = None,
        value: Optional[list[str]] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> list[str]:
        return self._x_checkbox_group(
            "switchgroup",
            key or self._new_widget_id("switch-group", label),
            description=description,
            error=error,
            format_func=format_func,
            groupProps=group_props,
            label=label,
            on_change=on_change,
            options=options,  # type: ignore[arg-type]
            readOnly=read_only,
            required=required,
            size=size,
            value=value,
            withAsterisk=with_asterisk,
            **kwargs,
        )

    def textarea(
        self,
        label: str,
        *,
        autosize: Optional[bool] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        error: Optional[str] = None,
        input_size: Optional[str] = None,
        key: Optional[str] = None,
        max_rows: Optional[int] = None,
        min_rows: Optional[int] = None,
        on_change: Optional[Callable[[str], None]] = None,
        radius: Optional[Union[str, int]] = None,
        required: Optional[bool] = None,
        resize: Optional[str] = None,
        value: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        return self._x_input(
            "textarea",
            key or self._new_widget_id("textarea", label),
            autosize=autosize,
            description=description,
            disabled=disabled,
            error=error,
            inputSize=input_size,
            label=label,
            maxRows=max_rows,
            minRows=min_rows,
            on_change=on_change,
            radius=radius,
            required=required,
            resize=resize,
            value=value,
            **kwargs,
        )

    def autocomplete(
        self,
        label: str,
        data: list[Union[str, GroupOption]],
        *,
        auto_select_on_blur: Optional[bool] = None,
        clear_button_props: Optional[dict[str, Any]] = None,
        clearable: Optional[bool] = None,
        combobox_props: Optional[dict[str, Any]] = None,
        default_drowndown_open: Optional[bool] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        dropdown_opened: Optional[bool] = None,
        error: Optional[str] = None,
        key: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        limit: Optional[int] = None,
        on_change: Optional[Callable[[str], None]] = None,
        radius: Optional[Union[str, int]] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        value: Optional[str] = None,
        with_asterisk: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        return self._x_input(
            "autocomplete",
            key or self._new_widget_id("autocomplete", label),
            autoSelectOnBlur=auto_select_on_blur,
            clearButtonProps=clear_button_props,
            clearable=clearable,
            comboboxProps=combobox_props,
            data=data,
            defaultDropdownOpen=default_drowndown_open,
            description=description,
            disabled=disabled,
            dropdownOpened=dropdown_opened,
            error=error,
            label=label,
            leftSection=left_section,
            leftSectionProps=left_section_props,
            leftSectionWidth=left_section_width,
            limit=limit,
            on_change=on_change,
            radius=radius,
            required=required,
            rightSection=right_section,
            rightSectionProps=right_section_props,
            rightSectionWidth=right_section_width,
            size=size,
            value=value,
            withAsterisk=with_asterisk,
            **kwargs,
        )

    def multiselect(
        self,
        label: str,
        data: list[Union[RLOption, str]],
        *,
        check_icon_position: Optional[Literal["left", "right"]] = None,
        chevron_color: Optional[str] = None,
        clear_button_props: Optional[dict[str, Any]] = None,
        clearable: Optional[bool] = None,
        combobox_props: Optional[dict[str, Any]] = None,
        default_dropdown_opened: Optional[bool] = None,
        default_search_value: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        dropdown_opened: Optional[bool] = None,
        error: Optional[str] = None,
        error_props: Optional[dict[str, Any]] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        hidden_input_props: Optional[dict[str, Any]] = None,
        hidden_input_values_divider: Optional[str] = None,
        hide_picked_options: Optional[bool] = None,
        input_size: Optional[str] = None,
        input_wrapper_order: Optional[list[str]] = None,
        key: Optional[str] = None,
        label_props: Optional[dict[str, Any]] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        limit: Optional[int] = None,
        max_dropdown_height: Optional[Union[str, int]] = None,
        max_values: Optional[int] = None,
        nothing_found_message: Optional[str] = None,
        on_change: Optional[Callable[[list[str]], None]] = None,
        radius: Optional[Union[str, int]] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        scroll_area_props: Optional[dict[str, Any]] = None,
        search_value: Optional[str] = None,
        searchable: Optional[bool] = None,
        select_first_option_on_change: Optional[bool] = None,
        size: Optional[str] = None,
        value: Optional[list[str]] = None,
        with_asterisk: Optional[bool] = None,
        with_check_icon: Optional[bool] = None,
        with_error_styles: Optional[bool] = None,
        with_scroll_area: Optional[bool] = None,
        **kwargs: Any,
    ) -> list[str]:
        return self._x_checkbox_group(
            "multiselect",
            key or self._new_widget_id("multiselect", label),
            checkIconPosition=check_icon_position,
            chevronColor=chevron_color,
            clearButtonProps=clear_button_props,
            clearable=clearable,
            comboboxProps=combobox_props,
            defaultDropdownOpened=default_dropdown_opened,
            defaultSearchValue=default_search_value,
            description=description,
            disabled=disabled,
            dropdownOpened=dropdown_opened,
            error=error,
            errorProps=error_props,
            format_func=format_func,
            hiddenInputProps=hidden_input_props,
            hiddenInputValuesDivider=hidden_input_values_divider,
            hidePickedOptions=hide_picked_options,
            inputSize=input_size,
            inputWrapperOrder=input_wrapper_order,
            label=label,
            labelProps=label_props,
            leftSection=left_section,
            leftSectionProps=left_section_props,
            leftSectionWidth=left_section_width,
            limit=limit,
            maxDropdownHeight=max_dropdown_height,
            maxValues=max_values,
            nothingFoundMessage=nothing_found_message,
            on_change=on_change,
            options=data,  # type: ignore[arg-type]
            options_attr="data",
            radius=radius,
            required=required,
            scrollAreaProps=scroll_area_props,
            rightSection=right_section,
            rightSectionProps=right_section_props,
            rightSectionWidth=right_section_width,
            searchValue=search_value,
            searchable=searchable,
            selectFirstOptionOnChange=select_first_option_on_change,
            size=size,
            value=value,
            withAsterisk=with_asterisk,
            withCheckIcon=with_check_icon,
            withErrorStyles=with_error_styles,
            withScrollArea=with_scroll_area,
            **kwargs,
        )

    def select(  # type: ignore[override]
        self,
        label: str,
        options: list[Union[RLOption, str]],
        *,
        allow_deselect: Optional[bool] = None,
        auto_select_on_blur: Optional[bool] = None,
        check_icon_position: Optional[Literal["left", "right"]] = None,
        chevron_color: Optional[str] = None,
        clearable: Optional[bool] = None,
        combobox_props: Optional[dict[str, Any]] = None,
        default_dropdown_opened: Optional[bool] = None,
        default_search_value: Optional[str] = None,
        description: Optional[str] = None,
        error: Optional[str] = None,
        format_func: Optional[Callable[[Any], str]] = None,
        hidden_input_props: Optional[dict[str, Any]] = None,
        input_size: Optional[str] = None,
        input_wrapper_order: Optional[list[str]] = None,
        key: Optional[str] = None,
        label_props: Optional[dict[str, Any]] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        limit: Optional[int] = None,
        max_dropdown_height: Optional[Union[str, int]] = None,
        nothing_found_message: Optional[str] = None,
        on_change: Optional[Callable[[Any], None]] = None,
        pointer: Optional[bool] = None,
        radius: Optional[Union[str, int]] = None,
        required: Optional[bool] = None,
        scroll_area_props: Optional[dict[str, Any]] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        value: Optional[Any] = None,
        with_asterisk: Optional[bool] = None,
        with_error_styles: Optional[bool] = None,
        with_scroll_area: Optional[bool] = None,
        **kwargs: Any,
    ) -> Any:
        return self._x_radio_select(
            "select",
            key or self._new_widget_id("select", label),
            options=options,  # type: ignore[arg-type]
            options_attr="data",
            value=value,
            on_change=on_change,
            format_func=format_func,
            label=label,
            allowDeselect=allow_deselect,
            autoSelectOnBlur=auto_select_on_blur,
            checkIconPosition=check_icon_position,
            chevronColor=chevron_color,
            clearable=clearable,
            comboboxProps=combobox_props,
            defaultDropdownOpened=default_dropdown_opened,
            defaultSearchValue=default_search_value,
            description=description,
            error=error,
            hiddenInputProps=hidden_input_props,
            inputSize=input_size,
            inputWrapperOrder=input_wrapper_order,
            labelProps=label_props,
            leftSection=left_section,
            leftSectionProps=left_section_props,
            leftSectionWidth=left_section_width,
            limit=limit,
            maxDropdownHeight=max_dropdown_height,
            nothingFoundMessage=nothing_found_message,
            pointer=pointer,
            radius=radius,
            rightSection=right_section,
            rightSectionProps=right_section_props,
            rightSectionWidth=right_section_width,
            required=required,
            scrollAreaProps=scroll_area_props,
            size=size,
            withAsterisk=with_asterisk,
            withErrorStyles=with_error_styles,
            withScrollArea=with_scroll_area,
            **kwargs,
        )

    def tags_input(
        self,
        label: str,
        data: list[Union[RLOption, GroupOption, str]],
        *,
        accept_value_on_blur: Optional[bool] = None,
        allow_duplicates: Optional[bool] = None,
        clear_button_props: Optional[dict[str, Any]] = None,
        clearable: Optional[bool] = None,
        combobox_props: Optional[dict[str, Any]] = None,
        default_dropdown_opened: Optional[bool] = None,
        default_search_value: Optional[str] = None,
        description: Optional[str] = None,
        description_props: Optional[dict[str, Any]] = None,
        disabled: Optional[bool] = None,
        dropdown_opened: Optional[bool] = None,
        error: Optional[str] = None,
        error_props: Optional[dict[str, Any]] = None,
        hidden_input_props: Optional[dict[str, Any]] = None,
        hidden_input_values_divider: Optional[str] = None,
        input_size: Optional[str] = None,
        input_wrapper_order: Optional[list[str]] = None,
        key: Optional[str] = None,
        label_props: Optional[dict[str, Any]] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        limit: Optional[int] = None,
        max_dropdown_height: Optional[Union[str, int]] = None,
        max_tags: Optional[int] = None,
        on_change: Optional[Callable[[list[str]], None]] = None,
        pointer: Optional[bool] = None,
        radius: Optional[Union[str, int]] = None,
        required: Optional[bool] = None,
        right_section: Optional[str] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        scroll_area_props: Optional[dict[str, Any]] = None,
        search_value: Optional[str] = None,
        select_first_option_on_change: Optional[bool] = None,
        size: Optional[str] = None,
        split_chars: Optional[list[str]] = None,
        value: Optional[list[str]] = None,
        with_asterisk: Optional[bool] = None,
        with_error_styles: Optional[bool] = None,
        with_scroll_area: Optional[bool] = None,
        **kwargs: Any,
    ) -> list[str]:
        return cast(
            list[str],
            self._x_checkbox_group(
                "tagsinput",
                key or self._new_widget_id("tagsinput", label),
                acceptValueOnBlur=accept_value_on_blur,
                allowDuplicates=allow_duplicates,
                clearButtonProps=clear_button_props,
                clearable=clearable,
                comboboxProps=combobox_props,
                defaultDropdownOpened=default_dropdown_opened,
                defaultSearchValue=default_search_value,
                description=description,
                descriptionProps=description_props,
                disabled=disabled,
                dropdownOpened=dropdown_opened,
                error=error,
                errorProps=error_props,
                hiddenInputProps=hidden_input_props,
                hiddenInputValuesDivider=hidden_input_values_divider,
                inputSize=input_size,
                inputWrapperOrder=input_wrapper_order,
                label=label,
                labelProps=label_props,
                leftSection=left_section,
                leftSectionProps=left_section_props,
                leftSectionWidth=left_section_width,
                limit=limit,
                maxDropdownHeight=max_dropdown_height,
                maxTags=max_tags,
                on_change=on_change,
                options=data,  # type: ignore[arg-type]
                options_attr="data",
                pointer=pointer,
                radius=radius,
                required=required,
                rightSection=right_section,
                rightSectionProps=right_section_props,
                rightSectionWidth=right_section_width,
                scrollAreaProps=scroll_area_props,
                searchValue=search_value,
                selectFirstOptionOnChange=select_first_option_on_change,
                size=size,
                splitChars=split_chars,
                value=value,
                withAsterisk=with_asterisk,
                withErrorStyles=with_error_styles,
                withScrollArea=with_scroll_area,
                **kwargs,
            ),
        )

    def action_icon(
        self,
        name: str,
        *,
        key: Optional[str] = None,
        on_click: Optional[Callable[[], None]] = None,
        rl_virtual: Optional[bool] = None,
        **kwargs: Any,
    ) -> bool:
        return self._x_button(
            "actionicon",
            key or self._new_widget_id("actionicon", name),
            name=name,
            on_click=on_click,
            rl_virtual=rl_virtual,
            **kwargs,
        )

    def action_icon_group(
        self,
        border_width: Optional[str] = None,
        orientation: Optional[Literal["horizontal", "vertical"]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        element = self._create_element(
            key=self._new_text_id("actionicongroup"),
            name="actionicongroup",
            props={
                "borderWidth": border_width,
                "orientation": orientation,
                **kwargs,
            },
            virtual=True,
        )
        return cast(RLBuilder, self._build_nested_builder(element))

    def action_icon_group_section(
        self,
        text: Optional[str] = None,
        rl_virtual: bool = True,
        **kwargs: Any,
    ) -> "RLBuilder":
        element = self._create_element(
            key=self._new_text_id("actionicongroupsection"),
            name="actionicongroupsection",
            props={
                "children": text,
                **kwargs,
            },
            virtual=rl_virtual,
        )
        return self._build_nested_builder(element)  # type: ignore[return-value]

    def button(
        self,
        text: str,
        *,
        color: Optional[str] = None,
        disabled: Optional[bool] = None,
        full_width: Optional[bool] = None,
        gradient: Optional[dict[str, Any]] = None,
        justify: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        loading: Optional[bool] = None,
        key: Optional[str] = None,
        on_click: Optional[Callable[[], None]] = None,
        radius: Optional[Union[str, int]] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        rl_virtual: Optional[bool] = None,
        size: Optional[str] = None,
        variant: Optional[str] = None,
        **kwargs: Any,
    ) -> bool:
        return self._x_button(
            "button",
            text,
            on_click=on_click,
            rl_virtual=rl_virtual,
            color=color,
            disabled=disabled,
            fullWidth=full_width,
            gradient=gradient,
            justify=justify,
            key=key or self._new_widget_id("button", text),
            leftSection=left_section,
            leftSectionProps=left_section_props,
            leftSectionWidth=left_section_width,
            loading=loading,
            radius=radius,
            rightSection=right_section,
            rightSectionProps=right_section_props,
            rightSectionWidth=right_section_width,
            size=size,
            variant=variant,
            **kwargs,
        )

    @staticmethod
    def icon(name: str, **kwargs: Any) -> RouteLitElement:
        return RouteLitElement(
            name="icon",
            key="",
            props={
                "name": name,
                **kwargs,
            },
            virtual=True,
        )

    def anchor(
        self,
        href: str,
        text: str,
        *,
        c: Optional[str] = None,
        gradient: Optional[dict[str, Any]] = None,
        inherit: Optional[bool] = None,
        inline: Optional[bool] = None,
        is_external: bool = False,
        line_clamp: Optional[int] = None,
        replace: bool = False,
        size: Optional[str] = None,
        truncate: Optional[str] = None,
        underline: Optional[str] = None,
        variant: Optional[str] = None,
        **kwargs: Any,
    ) -> RouteLitElement:
        return self.link(
            href,
            text,
            c=c,
            rl_element_type="anchor",
            gradient=gradient,
            is_external=is_external,
            inherit=inherit,
            inline=inline,
            lineClamp=line_clamp,
            replace=replace,
            size=size,
            truncate=truncate,
            underline=underline,
            variant=variant,
            **kwargs,
        )

    def nav_link(
        self,
        href: str,
        label: str,
        *,
        active: Optional[bool] = None,
        auto_contrast: Optional[bool] = None,
        children_offset: Optional[str] = None,
        color: Optional[str] = None,
        default_opened: Optional[bool] = None,
        description: Optional[str] = None,
        disable_right_section_rotation: Optional[bool] = None,
        disabled: Optional[bool] = None,
        exact: Optional[bool] = None,
        is_external: bool = False,
        left_section: Optional[RouteLitElement] = None,
        no_wrap: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        element = self.link(
            href,
            label,
            active=active,
            autoContrast=auto_contrast,
            childrenOffset=children_offset,
            color=color,
            defaultOpened=default_opened,
            description=description,
            disableRightSectionRotation=disable_right_section_rotation,
            disabled=disabled,
            exact=exact,
            is_external=is_external,
            leftSection=left_section,
            noWrap=no_wrap,
            rightSection=right_section,
            rl_element_type="navlink",
            rl_text_attr="label",
            **kwargs,
        )
        return self._build_nested_builder(element)  # type: ignore[return-value]

    def tabs(
        self,
        tabs: list[Union[MTTab, str]],
        *,
        activate_tab_with_keyboard: Optional[bool] = None,
        allow_tab_deactivation: Optional[bool] = None,
        auto_contrast: Optional[bool] = None,
        color: Optional[str] = None,
        default_value: Optional[str] = None,
        inverted: Optional[bool] = None,
        keep_mounted: Optional[bool] = None,
        key: Optional[str] = None,
        loop: Optional[bool] = None,
        orientation: Optional[Literal["horizontal", "vertical"]] = None,
        placement: Optional[Literal["left", "right"]] = None,
        radius: Optional[Union[str, int]] = None,
        tablist_grow: Optional[bool] = None,
        tablist_justify: Optional[str] = None,
        variant: Optional[Literal["default", "outline", "pills"]] = None,
        **kwargs: Any,
    ) -> tuple["RLBuilder", ...]:
        default_value = default_value or (
            (tabs[0]["value"] if isinstance(tabs[0], dict) else tabs[0]) if tabs and len(tabs) > 0 else None
        )
        tabs_root = self._build_nested_builder(
            self._create_element(
                key=key or self._new_text_id("tabs"),
                name="tabs",
                props={
                    "activateTabWithKeyboard": activate_tab_with_keyboard,
                    "allowTabDeactivation": allow_tab_deactivation,
                    "autoContrast": auto_contrast,
                    "color": color,
                    "defaultValue": default_value,
                    "inverted": inverted,
                    "keepMounted": keep_mounted,
                    "loop": loop,
                    "orientation": orientation,
                    "placement": placement,
                    "radius": radius,
                    "variant": variant,
                    **kwargs,
                },
                virtual=True,
            )
        )
        tabs_panels = []
        with tabs_root:
            tab_list = self._build_nested_builder(
                self._create_element(
                    key=self._new_text_id("tablist"),
                    name="tablist",
                    props={
                        "grow": tablist_grow,
                        "justify": tablist_justify,
                    },
                    virtual=True,
                )
            )
            for tab in tabs:
                tab_props = {"value": tab} if isinstance(tab, str) else tab
                keep_mounted_val = tab_props.pop("keep_mounted", None)
                keep_mounted = keep_mounted_val if isinstance(keep_mounted_val, (bool, type(None))) else None
                left_section = tab_props.pop("left_section", None)
                right_section = tab_props.pop("right_section", None)
                label = tab_props.pop("label", None)
                tab_props["children"] = label or tab_props["value"]
                if left_section:
                    tab_props["leftSection"] = left_section  # type: ignore[assignment, arg-type]
                if right_section:
                    tab_props["rightSection"] = right_section  # type: ignore[assignment, arg-type]
                with tab_list:
                    self._create_element(
                        key=self._new_text_id("tab"),
                        name="tab",
                        props=tab_props,  # type: ignore[arg-type]
                        virtual=True,
                    )
                tabs_panels.append(
                    self._build_nested_builder(
                        self._create_element(
                            key=self._new_text_id("tabpanel"),
                            name="tabpanel",
                            props={
                                "value": tab_props["value"],
                                "keepMounted": keep_mounted,
                            },
                            virtual=True,
                        )
                    )
                )
        return tuple(tabs_panels)  # type: ignore[arg-type]

    @staticmethod
    def tab(
        value: str,
        label: Optional[str] = None,
        color: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        right_section: Optional[RouteLitElement] = None,
        size: Optional[Union[str, int]] = None,
        keep_mounted: Optional[bool] = None,
        **kwargs: Any,
    ) -> MTTab:
        return MTTab(  # type: ignore[no-any-return]
            value=value,
            label=label,
            color=color,
            left_section=left_section,
            right_section=right_section,
            size=size,
            keep_mounted=keep_mounted,
            **kwargs,  # type: ignore[typeddict-item]
        )

    def alert(
        self,
        title: str,
        *,
        auto_contrast: Optional[bool] = None,
        key: Optional[str] = None,
        color: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        icon: Optional[RouteLitElement] = None,
        with_close_button: Optional[bool] = None,
        close_button_label: Optional[str] = None,
        on_close: Optional[Callable[[], bool]] = None,
        variant: Optional[Literal["default", "filled", "light", "outline", "white", "transparent"]] = None,
        text: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._x_dialog(  # type: ignore[return-value]
            "alert",
            key or self._new_widget_id("alert", title),
            autoContrast=auto_contrast,
            closeButtonLabel=close_button_label,
            color=color,
            radius=radius,
            icon=icon,
            title=title,
            on_close=on_close,
            variant=variant,
            withCloseButton=with_close_button,
            children=text,
            **kwargs,
        )

    def notification(
        self,
        title: str,
        *,
        key: Optional[str] = None,
        close_button_props: Optional[dict[str, Any]] = None,
        color: Optional[str] = None,
        icon: Optional[RouteLitElement] = None,
        on_close: Optional[Callable[[], bool]] = None,
        radius: Optional[Union[str, int]] = None,
        text: Optional[str] = None,
        with_border: Optional[bool] = None,
        with_close_button: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._x_dialog(  # type: ignore[return-value]
            "notification",
            key or self._new_widget_id("notification", title),
            closeButtonProps=close_button_props,
            color=color,
            radius=radius,
            icon=icon,
            title=title,
            on_close=on_close,
            withBorder=with_border,
            withCloseButton=with_close_button,
            children=text,
            **kwargs,
        )

    def progress(
        self,
        value: float,
        *,
        key: Optional[str] = None,
        animated: Optional[bool] = None,
        auto_contrast: Optional[bool] = None,
        color: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        size: Optional[Union[str, int]] = None,
        striped: Optional[bool] = None,
        transition_duration: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            key=key or self._new_text_id("progress"),
            name="progress",
            props={
                "value": value,
                "animated": animated,
                "autoContrast": auto_contrast,
                "color": color,
                "radius": radius,
                "size": size,
                "striped": striped,
                "transitionDuration": transition_duration,
                **kwargs,
            },
        )

    def dialog(
        self,
        key: Optional[str] = None,
        *,
        with_close_button: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return super()._x_dialog(  # type: ignore[return-value]
            "dialog",
            key or self._new_text_id("dialog"),
            opened=True,
            withCloseButton=with_close_button,
            **kwargs,
        )

    def drawer(
        self,
        key: Optional[str] = None,
        *,
        close_button_props: Optional[dict] = None,
        close_on_click_outside: Optional[bool] = None,
        close_on_escape: Optional[bool] = None,
        on_close: Optional[Callable[[], bool]] = None,
        keep_mounted: Optional[bool] = None,
        lock_scroll: Optional[bool] = None,
        offset: Optional[Union[str, int]] = None,
        overlay_props: Optional[dict] = None,
        padding: Optional[Union[str, int]] = None,
        portal_props: Optional[dict] = None,
        position: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        remove_scroll_props: Optional[dict] = None,
        return_focus: Optional[bool] = None,
        scroll_area_component: Optional[str] = None,
        shadow: Optional[str] = None,
        size: Optional[Union[str, int]] = None,
        stack_id: Optional[str] = None,
        title: Optional[str] = None,
        transition_props: Optional[dict] = None,
        trap_focus: Optional[bool] = None,
        with_close_button: Optional[bool] = None,
        with_overlay: Optional[bool] = None,
        within_portal: Optional[bool] = None,
        z_index: Optional[Union[str, int]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return super()._x_dialog(  # type: ignore[return-value]
            "drawer",
            key or self._new_text_id("drawer"),
            opened=True,
            closeButtonProps=close_button_props,
            closeOnClickOutside=close_on_click_outside,
            closeOnEscape=close_on_escape,
            keepMounted=keep_mounted,
            lockScroll=lock_scroll,
            offset=offset,
            on_close=on_close,
            overlayProps=overlay_props,
            padding=padding,
            portalProps=portal_props,
            position=position,
            radius=radius,
            removeScrollProps=remove_scroll_props,
            returnFocus=return_focus,
            scrollAreaComponent=scroll_area_component,
            shadow=shadow,
            size=size,
            stackId=stack_id,
            title=title,
            transitionProps=transition_props,
            trapFocus=trap_focus,
            withCloseButton=with_close_button,
            withOverlay=with_overlay,
            withinPortal=within_portal,
            zIndex=z_index,
            **kwargs,
        )

    def modal(
        self,
        key: Optional[str] = None,
        *,
        title: Optional[str] = None,
        with_close_button: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return super()._x_dialog(  # type: ignore[return-value]
            "modal",
            key or self._new_text_id("modal"),
            opened=True,
            title=title,
            withCloseButton=with_close_button,
            **kwargs,
        )

    # override _dialog to use modal instead of dialog
    def _dialog(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self.modal(key or self._new_text_id("modal"), **kwargs)

    def affix(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="affix",
            key=key or self._new_text_id("affix"),
            props=kwargs,
            virtual=True,
        )

    def image(
        self,
        src: str,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            name="image",
            key=key or self._new_widget_id("image", src),
            props={"src": src, **kwargs},
        )

    def number_formatter(
        self,
        value: Union[float, int, str],
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            key=key or self._new_text_id("numberformatter"),
            name="numberformatter",
            props={"value": value, **kwargs},
        )

    def spoiler(
        self,
        show_label: str = "Show more",
        hide_label: str = "Show less",
        *,
        key: Optional[str] = None,
        initial_state: bool = False,
        max_height: Optional[int] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="spoiler",
            key=key or self._new_text_id("spoiler"),
            props={
                "showLabel": show_label,
                "hideLabel": hide_label,
                "initialState": initial_state,
                "maxHeight": max_height,
                **kwargs,
            },
            virtual=True,
        )

    def text(  # type: ignore[override]
        self,
        text: str,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            name="text",
            key=key or self._new_text_id("text"),
            props={"children": text, **kwargs},
        )

    def title(  # type: ignore[override]
        self,
        text: str,
        *,
        key: Optional[str] = None,
        order: Optional[int] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            name="title",
            key=key or self._new_text_id("title"),
            props={"children": text, "order": order, **kwargs},
        )

    def table(
        self,
        key: Optional[str] = None,
        *,
        body: Optional[list[list[Any]]] = None,
        caption: Optional[str] = None,
        head: Optional[list[str]] = None,
        foot: Optional[list[str]] = None,
        sticky_header: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        data = {
            "body": body,
            "caption": caption,
            "head": head,
            "foot": foot,
        }
        return self._create_builder_element(  # type: ignore[return-value]
            name="table",
            key=key or self._new_text_id("table"),
            props={"data": data, "stickyHeader": sticky_header, **kwargs},
        )

    def table_caption(
        self,
        text: str,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        self._create_element(
            name="tablecaption",
            key=key or self._new_text_id("tablecaption"),
            props={"children": text, **kwargs},
            virtual=True,
        )

    def table_head(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablehead",
            key=key or self._new_text_id("tablehead"),
            props=kwargs,
            virtual=True,
        )

    def table_foot(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablefoot",
            key=key or self._new_text_id("tablefoot"),
            props=kwargs,
            virtual=True,
        )

    def table_row(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablerow",
            key=key or self._new_text_id("tablerow"),
            props=kwargs,
            virtual=True,
        )

    def table_cell(
        self,
        text: Optional[str] = None,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablecell",
            key=key or self._new_text_id("tablecell"),
            props={"children": text, **kwargs},
            virtual=True,
        )

    def table_header(
        self,
        text: Optional[str] = None,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tableheader",
            key=key or self._new_text_id("tableheader"),
            props={"children": text, **kwargs},
            virtual=True,
        )

    def table_body(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablebody",
            key=key or self._new_text_id("tablebody"),
            props=kwargs,
            virtual=True,
        )

    def table_scroll_container(
        self,
        *,
        key: Optional[str] = None,
        max_height: Optional[Union[str, int]] = None,
        max_width: Optional[Union[str, int]] = None,
        min_height: Optional[Union[str, int]] = None,
        min_width: Optional[Union[str, int]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="tablescrollcontainer",
            key=key or self._new_text_id("tablescrollcontainer"),
            props={
                "maxHeight": max_height,
                "maxWidth": max_width,
                "minHeight": min_height,
                "minWidth": min_width,
                **kwargs,
            },
            virtual=True,
        )

    def box(
        self,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="box",
            key=key or self._new_text_id("box"),
            props=kwargs,
            virtual=True,
        )

    def paper(
        self,
        *,
        key: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        shadow: Optional[str] = None,
        with_border: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="paper",
            key=key or self._new_text_id("paper"),
            props={
                "radius": radius,
                "shadow": shadow,
                "withBorder": with_border,
                **kwargs,
            },
            virtual=True,
        )

    def scroll_area(
        self,
        *,
        key: Optional[str] = None,
        offset_scrollbars: Optional[Union[bool, Literal["x", "y", "present"]]] = None,
        overscroll_behavior: Optional[str] = None,
        scroll_hide_delay: Optional[int] = None,
        scrollbar_size: Optional[Union[str, int]] = None,
        scrollbars: Optional[Union[bool, Literal["x", "y", "xy"]]] = None,
        type: Optional[Literal["auto", "scroll", "always", "hover", "never"]] = None,
        viewport_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="scrollarea",
            key=key or self._new_text_id("scrollarea"),
            props={
                "offsetScrollbars": offset_scrollbars,
                "overscrollBehavior": overscroll_behavior,
                "scrollHideDelay": scroll_hide_delay,
                "scrollbarSize": scrollbar_size,
                "scrollbars": scrollbars,
                "type": type,
                "viewportProps": viewport_props,
                **kwargs,
            },
            virtual=True,
        )

    def _format_datetime(self, value: Any) -> Optional[datetime.datetime]:
        if isinstance(value, datetime.datetime):
            return value
        if isinstance(value, str):
            return datetime.datetime.fromisoformat(value)
        return None

    def date_time_picker(
        self,
        label: str,
        value: Optional[Union[datetime.datetime, str]] = None,
        *,
        clearable: Optional[bool] = None,
        columns_to_scroll: Optional[int] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        dropdown_type: Optional[Literal["modal", "popover"]] = None,
        error: Optional[str] = None,
        first_day_of_week: Optional[Literal[0, 1, 2, 3, 4, 5, 6]] = None,
        header_controls_order: Optional[list[Literal["level", "next", "previous"]]] = None,
        hide_outside_dates: Optional[bool] = None,
        hide_weekdays: Optional[bool] = None,
        highlight_today: Optional[bool] = None,
        input_size: Optional[str] = None,
        input_wrapper_order: Optional[list[str]] = None,
        label_props: Optional[dict[str, Any]] = None,
        label_separator: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_props: Optional[dict[str, Any]] = None,
        left_section_width: Optional[str] = None,
        level: Optional[Literal["month", "year", "decade"]] = None,
        locale: Optional[str] = None,
        max_date: Optional[Union[datetime.datetime, str]] = None,
        max_level: Optional[Literal["month", "year", "decade"]] = None,
        min_date: Optional[Union[datetime.datetime, str]] = None,
        months_list_format: Optional[str] = None,
        number_of_columns: Optional[int] = None,
        next_label: Optional[str] = None,
        next_icon: Optional[RouteLitElement] = None,
        on_change: Optional[Callable[[datetime.datetime], None]] = None,
        popover_props: Optional[dict[str, Any]] = None,
        presets: Optional[list[dict[str, Any]]] = None,
        previous_icon: Optional[RouteLitElement] = None,
        previous_label: Optional[str] = None,
        placeholder: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        read_only: Optional[bool] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_pointer_events: Optional[str] = None,
        right_section_props: Optional[dict[str, Any]] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        sort_dates: Optional[bool] = None,
        submit_button_props: Optional[dict[str, Any]] = None,
        time_picker_props: Optional[dict[str, Any]] = None,
        value_format: Optional[str] = None,
        weekday_format: Optional[str] = None,
        weekend_days: Optional[list[Literal[0, 1, 2, 3, 4, 5, 6]]] = None,
        with_asterisk: Optional[bool] = None,
        with_cell_spacing: Optional[bool] = None,
        with_error_styles: Optional[bool] = None,
        with_seconds: Optional[bool] = None,
        with_week_numbers: Optional[bool] = None,
        wrapper_props: Optional[dict[str, Any]] = None,
        year_label_format: Optional[str] = None,
        years_list_format: Optional[str] = None,
        pointer: Optional[bool] = None,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[datetime.datetime]:
        return cast(
            Optional[datetime.datetime],
            self._x_input(
                "datetimepicker",
                key or self._new_widget_id("datetimepicker", label),
                clearable=clearable,
                columnsToScroll=columns_to_scroll,
                description=description,
                disabled=disabled,
                dropdownType=dropdown_type,
                error=error,
                firstDayOfWeek=first_day_of_week,
                headerControlsOrder=header_controls_order,
                hideOutsideDates=hide_outside_dates,
                hideWeekdays=hide_weekdays,
                highlightToday=highlight_today,
                inputSize=input_size,
                inputWrapperOrder=input_wrapper_order,
                label=label,
                labelProps=label_props,
                labelSeparator=label_separator,
                value=value,
                leftSection=left_section,
                leftSectionProps=left_section_props,
                leftSectionWidth=left_section_width,
                level=level,
                locale=locale,
                maxDate=max_date,
                maxLevel=max_level,
                minDate=min_date,
                monthsListFormat=months_list_format,
                nextIcon=next_icon,
                nextLabel=next_label,
                numberOfColumns=number_of_columns,
                on_change=on_change,
                popoverProps=popover_props,
                presets=presets,
                previousIcon=previous_icon,
                previousLabel=previous_label,
                placeholder=placeholder,
                radius=radius,
                readOnly=read_only,
                required=required,
                rightSection=right_section,
                rightSectionPointerEvents=right_section_pointer_events,
                rightSectionProps=right_section_props,
                rightSectionWidth=right_section_width,
                rl_format_func=self._format_datetime,
                size=size,
                sortDates=sort_dates,
                submitButtonProps=submit_button_props,
                timePickerProps=time_picker_props,
                valueFormat=value_format,
                weekdayFormat=weekday_format,
                weekendDays=weekend_days,
                withAsterisk=with_asterisk,
                withCellSpacing=with_cell_spacing,
                withErrorStyles=with_error_styles,
                withSeconds=with_seconds,
                withWeekNumbers=with_week_numbers,
                wrapperProps=wrapper_props,
                yearLabelFormat=year_label_format,
                yearsListFormat=years_list_format,
                pointer=pointer,
                **kwargs,
            ),
        )

    def _format_date_picker(
        self, value: Any
    ) -> Optional[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]]:
        if isinstance(value, datetime.date):
            return value
        if isinstance(value, str):
            return datetime.date.fromisoformat(value)
        if isinstance(value, list):
            return [datetime.date.fromisoformat(x) if isinstance(x, str) else x for x in value]
        return None

    def date_picker(
        self,
        label: str,
        value: Optional[
            Union[
                datetime.date, str, list[str], list[datetime.date], tuple[str, str], tuple[datetime.date, datetime.date]
            ]
        ] = None,
        *,
        allow_deselect: Optional[bool] = None,
        allow_single_date_in_range: Optional[bool] = None,
        aria_labels: Optional[dict] = None,
        columns_to_scroll: Optional[int] = None,
        decade_label_format: Optional[str] = None,
        default_level: Optional[Literal["month", "year", "decade"]] = None,
        description: Optional[str] = None,
        enable_keyboard_navigation: Optional[bool] = None,
        first_day_of_week: Optional[Literal[0, 1, 2, 3, 4, 5, 6]] = None,
        header_controls_order: Optional[list[Literal["level", "next", "previous"]]] = None,
        hide_outside_dates: Optional[bool] = None,
        hide_weekdays: Optional[bool] = None,
        highlight_today: Optional[bool] = None,
        key: Optional[str] = None,
        level: Optional[str] = None,
        locale: Optional[str] = None,
        max_date: Optional[Union[str, datetime.date]] = None,
        max_level: Optional[str] = None,
        min_date: Optional[Union[str, datetime.date]] = None,
        month_label_format: Optional[str] = None,
        months_list_format: Optional[str] = None,
        next_icon: Optional[RouteLitElement] = None,
        next_label: Optional[str] = None,
        number_of_columns: Optional[int] = None,
        on_change: Optional[
            Callable[[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]], None]
        ] = None,
        presets: Optional[list] = None,
        previous_icon: Optional[RouteLitElement] = None,
        previous_label: Optional[str] = None,
        size: Optional[str] = None,
        type: Optional[Literal["default", "range", "multiple"]] = None,
        weekday_format: Optional[str] = None,
        weekend_days: Optional[list[Literal[0, 1, 2, 3, 4, 5, 6]]] = None,
        with_cell_spacing: Optional[bool] = None,
        with_week_numbers: Optional[bool] = None,
        year_label_format: Optional[str] = None,
        years_list_format: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]]:
        return cast(
            Optional[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]],
            self._x_input(
                "datepicker",
                key or self._new_widget_id("datepicker", label),
                label=label,
                description=description,
                value=value,
                allowDeselect=allow_deselect,
                allowSingleDateInRange=allow_single_date_in_range,
                ariaLabels=aria_labels,
                columnsToScroll=columns_to_scroll,
                decadeLabelFormat=decade_label_format,
                defaultLevel=default_level,
                enableKeyboardNavigation=enable_keyboard_navigation,
                firstDayOfWeek=first_day_of_week,
                headerControlsOrder=header_controls_order,
                hideOutsideDates=hide_outside_dates,
                hideWeekdays=hide_weekdays,
                highlightToday=highlight_today,
                level=level,
                locale=locale,
                maxDate=max_date,
                maxLevel=max_level,
                minDate=min_date,
                monthLabelFormat=month_label_format,
                monthsListFormat=months_list_format,
                nextIcon=next_icon,
                nextLabel=next_label,
                numberOfColumns=number_of_columns,
                onChange=on_change,
                presets=presets,
                previousIcon=previous_icon,
                previousLabel=previous_label,
                size=size,
                type=type,
                weekdayFormat=weekday_format,
                weekendDays=weekend_days,
                withCellSpacing=with_cell_spacing,
                withWeekNumbers=with_week_numbers,
                yearLabelFormat=year_label_format,
                yearsListFormat=years_list_format,
                rl_format_func=self._format_date_picker,
                **kwargs,
            ),
        )

    def date_picker_input(
        self,
        label: str,
        value: Optional[
            Union[
                datetime.date, str, list[str], list[datetime.date], tuple[str, str], tuple[datetime.date, datetime.date]
            ]
        ] = None,
        *,
        key: Optional[str] = None,
        description: Optional[str] = None,
        on_change: Optional[Callable[[Any], None]] = None,
        allow_deselect: Optional[bool] = None,
        allow_single_date_in_range: Optional[bool] = None,
        aria_labels: Optional[dict] = None,
        clear_button_props: Optional[dict] = None,
        clearable: Optional[bool] = None,
        close_on_change: Optional[bool] = None,
        columns_to_scroll: Optional[int] = None,
        decade_label_format: Optional[str] = None,
        default_level: Optional[Literal["month", "year", "decade"]] = None,
        description_props: Optional[dict] = None,
        disabled: Optional[bool] = None,
        dropdown_type: Optional[Literal["modal", "popover"]] = None,
        enable_keyboard_navigation: Optional[bool] = None,
        error: Optional[str] = None,
        error_props: Optional[dict] = None,
        first_day_of_week: Optional[Literal[0, 1, 2, 3, 4, 5, 6]] = None,
        header_controls_order: Optional[list[Literal["level", "next", "previous"]]] = None,
        hide_outside_dates: Optional[bool] = None,
        hide_weekdays: Optional[bool] = None,
        highlight_today: Optional[bool] = None,
        input_size: Optional[str] = None,
        input_wrapper_order: Optional[list[Literal["input", "label", "description", "error"]]] = None,
        label_props: Optional[dict] = None,
        label_separator: Optional[str] = None,
        left_section: Optional[RouteLitElement] = None,
        left_section_pointer_events: Optional[str] = None,
        left_section_props: Optional[dict] = None,
        left_section_width: Optional[str] = None,
        level: Optional[Literal["month", "year", "decade"]] = None,
        locale: Optional[str] = None,
        max_date: Optional[Union[str, datetime.date]] = None,
        max_level: Optional[Literal["month", "year", "decade"]] = None,
        min_date: Optional[Union[str, datetime.date]] = None,
        modal_props: Optional[dict] = None,
        month_label_format: Optional[str] = None,
        months_list_format: Optional[str] = None,
        next_icon: Optional[RouteLitElement] = None,
        next_label: Optional[str] = None,
        number_of_columns: Optional[int] = None,
        placeholder: Optional[str] = None,
        pointer: Optional[bool] = None,
        popover_props: Optional[dict] = None,
        presets: Optional[list] = None,
        previous_icon: Optional[RouteLitElement] = None,
        previous_label: Optional[str] = None,
        radius: Optional[Union[str, int]] = None,
        read_only: Optional[bool] = None,
        required: Optional[bool] = None,
        right_section: Optional[RouteLitElement] = None,
        right_section_pointer_events: Optional[str] = None,
        right_section_props: Optional[dict] = None,
        right_section_width: Optional[str] = None,
        size: Optional[str] = None,
        sort_dates: Optional[bool] = None,
        type: Optional[str] = None,
        value_format: Optional[str] = None,
        weekday_format: Optional[str] = None,
        weekend_days: Optional[list] = None,
        with_asterisk: Optional[bool] = None,
        with_cell_spacing: Optional[bool] = None,
        with_error_styles: Optional[bool] = None,
        with_week_numbers: Optional[bool] = None,
        wrapper_props: Optional[dict] = None,
        year_label_format: Optional[str] = None,
        years_list_format: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]]:
        return cast(
            Optional[Union[datetime.date, list[datetime.date], tuple[datetime.date, datetime.date]]],
            self._x_input(
                "datepickerinput",
                key or self._new_widget_id("datepickerinput", label),
                label=label,
                description=description,
                value=value,
                allowDeselect=allow_deselect,
                allowSingleDateInRange=allow_single_date_in_range,
                ariaLabels=aria_labels,
                clearButtonProps=clear_button_props,
                clearable=clearable,
                closeOnChange=close_on_change,
                columnsToScroll=columns_to_scroll,
                decadeLabelFormat=decade_label_format,
                defaultLevel=default_level,
                descriptionProps=description_props,
                disabled=disabled,
                dropdownType=dropdown_type,
                enableKeyboardNavigation=enable_keyboard_navigation,
                error=error,
                errorProps=error_props,
                firstDayOfWeek=first_day_of_week,
                headerControlsOrder=header_controls_order,
                hideOutsideDates=hide_outside_dates,
                hideWeekdays=hide_weekdays,
                highlightToday=highlight_today,
                inputSize=input_size,
                inputWrapperOrder=input_wrapper_order,
                labelProps=label_props,
                labelSeparator=label_separator,
                leftSection=left_section,
                leftSectionPointerEvents=left_section_pointer_events,
                leftSectionProps=left_section_props,
                leftSectionWidth=left_section_width,
                level=level,
                locale=locale,
                maxDate=max_date,
                maxLevel=max_level,
                minDate=min_date,
                modalProps=modal_props,
                monthLabelFormat=month_label_format,
                monthsListFormat=months_list_format,
                nextIcon=next_icon,
                nextLabel=next_label,
                numberOfColumns=number_of_columns,
                on_change=on_change,
                placeholder=placeholder,
                pointer=pointer,
                popoverProps=popover_props,
                presets=presets,
                previousIcon=previous_icon,
                previousLabel=previous_label,
                radius=radius,
                readOnly=read_only,
                required=required,
                rightSection=right_section,
                rightSectionPointerEvents=right_section_pointer_events,
                rightSectionProps=right_section_props,
                rightSectionWidth=right_section_width,
                size=size,
                sortDates=sort_dates,
                type=type,
                valueFormat=value_format,
                weekdayFormat=weekday_format,
                weekendDays=weekend_days,
                withAsterisk=with_asterisk,
                withCellSpacing=with_cell_spacing,
                withErrorStyles=with_error_styles,
                withWeekNumbers=with_week_numbers,
                wrapperProps=wrapper_props,
                yearLabelFormat=year_label_format,
                yearsListFormat=years_list_format,
                rl_format_func=self._format_date_picker,
                **kwargs,
            ),
        )

    def _format_time(self, value: Optional[Union[datetime.time, str]]) -> Optional[datetime.time]:
        if value is None:
            return None
        if isinstance(value, str):
            return datetime.time.fromisoformat(value)
        return value

    def time_input(
        self,
        label: Optional[str] = None,
        value: Optional[Union[datetime.time, str]] = None,
        *,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[datetime.time]:
        return cast(
            Optional[datetime.time],
            self._x_input(
                name="timeinput",
                key=key or self._new_text_id("timeinput"),
                label=label,
                value=value,
                rl_format_func=self._format_time,
                **kwargs,
            ),
        )

    def area_chart(
        self,
        data: list,
        data_key: str,
        series: list[dict[str, Any]],
        *,
        key: Optional[str] = None,
        active_dot_props: Optional[dict[str, Any]] = None,
        area_chart_props: Optional[dict[str, Any]] = None,
        area_props: Optional[dict[str, Any]] = None,
        connect_nulls: Optional[bool] = None,
        curve_type: Optional[str] = None,
        dot_props: Optional[dict[str, Any]] = None,
        fill_opacity: float = 0.2,
        grid_axis: Optional[str] = None,
        grid_color: Optional[str] = None,
        grid_props: Optional[dict[str, Any]] = None,
        legend_props: Optional[dict[str, Any]] = None,
        orientation: Optional[str] = None,
        reference_lines: Optional[list[dict[str, Any]]] = None,
        right_y_axis_label: Optional[str] = None,
        right_y_axis_props: Optional[dict[str, Any]] = None,
        split_colors: Optional[list[str]] = None,
        split_offset: Optional[float] = None,
        stroke_dasharray: Optional[Union[str, int]] = None,
        stroke_width: Optional[int] = None,
        text_color: Optional[str] = None,
        tick_line: Optional[str] = None,
        tooltip_animation_duration: int = 0,
        tooltip_props: Optional[dict[str, Any]] = None,
        type: Optional[str] = None,
        unit: Optional[str] = None,
        with_dots: Optional[bool] = None,
        with_gradient: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_point_labels: Optional[bool] = None,
        with_right_y_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_x_axis: Optional[bool] = None,
        with_y_axis: Optional[bool] = None,
        x_axis_label: Optional[str] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_label: Optional[str] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="areachart",
            key=key or self._new_text_id("areachart"),
            props={
                "data": data,
                "dataKey": data_key,
                "series": series,
                "activeDotProps": active_dot_props,
                "areaChartProps": area_chart_props,
                "areaProps": area_props,
                "connectNulls": connect_nulls,
                "curveType": curve_type,
                "dotProps": dot_props,
                "fillOpacity": fill_opacity,
                "gridAxis": grid_axis,
                "gridColor": grid_color,
                "gridProps": grid_props,
                "legendProps": legend_props,
                "orientation": orientation,
                "referenceLines": reference_lines,
                "rightYAxisLabel": right_y_axis_label,
                "rightYAxisProps": right_y_axis_props,
                "splitColors": split_colors,
                "splitOffset": split_offset,
                "strokeDasharray": stroke_dasharray,
                "strokeWidth": stroke_width,
                "textColor": text_color,
                "tickLine": tick_line,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "type": type,
                "unit": unit,
                "withDots": with_dots,
                "withGradient": with_gradient,
                "withLegend": with_legend,
                "withPointLabels": with_point_labels,
                "withRightYAxis": with_right_y_axis,
                "withTooltip": with_tooltip,
                "withXAxis": with_x_axis,
                "withYAxis": with_y_axis,
                "xAxisLabel": x_axis_label,
                "xAxisProps": x_axis_props,
                "yAxisLabel": y_axis_label,
                "yAxisProps": y_axis_props,
                **kwargs,
            },
        )

    def bar_chart(
        self,
        data: list,
        data_key: str,
        series: list[dict[str, Any]],
        *,
        bar_chart_props: Optional[dict[str, Any]] = None,
        bar_label_color: Optional[str] = None,
        bar_props: Optional[dict[str, Any]] = None,
        cursor_fill: Optional[str] = None,
        fill_opacity: Optional[float] = None,
        get_bar_color: Optional[Callable[[float, dict[str, Any]], str]] = None,
        grid_axis: Optional[Literal["none", "x", "y", "xy"]] = None,
        grid_color: Optional[str] = None,
        grid_props: Optional[dict[str, Any]] = None,
        key: Optional[str] = None,
        legend_props: Optional[dict[str, Any]] = None,
        max_bar_width: Optional[int] = None,
        min_bar_size: Optional[int] = None,
        orientation: Optional[Literal["horizontal", "vertical"]] = None,
        reference_lines: Optional[list[dict[str, Any]]] = None,
        right_y_axis_label: Optional[str] = None,
        right_y_axis_props: Optional[dict[str, Any]] = None,
        stroke_dasharray: Optional[Union[str, int]] = None,
        text_color: Optional[str] = None,
        tick_line: Optional[Literal["none", "x", "y", "xy"]] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        type: Optional[str] = None,
        unit: Optional[str] = None,
        value_label_props: Optional[dict[str, Any]] = None,
        with_bar_value_label: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_right_y_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_x_axis: Optional[bool] = None,
        with_y_axis: Optional[bool] = None,
        x_axis_label: Optional[str] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_label: Optional[str] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="barchart",
            key=key or self._new_text_id("barchart"),
            props={
                "data": data,
                "dataKey": data_key,
                "series": series,
                "barChartProps": bar_chart_props,
                "barLabelColor": bar_label_color,
                "barProps": bar_props,
                "cursorFill": cursor_fill,
                "fillOpacity": fill_opacity,
                "getBarColor": get_bar_color,
                "gridAxis": grid_axis,
                "gridColor": grid_color,
                "gridProps": grid_props,
                "legendProps": legend_props,
                "maxBarWidth": max_bar_width,
                "minBarSize": min_bar_size,
                "orientation": orientation,
                "referenceLines": reference_lines,
                "rightYAxisLabel": right_y_axis_label,
                "rightYAxisProps": right_y_axis_props,
                "strokeDasharray": stroke_dasharray,
                "textColor": text_color,
                "tickLine": tick_line,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "type": type,
                "unit": unit,
                "valueLabelProps": value_label_props,
                "withBarValueLabel": with_bar_value_label,
                "withLegend": with_legend,
                "withRightYAxis": with_right_y_axis,
                "withTooltip": with_tooltip,
                "withXAxis": with_x_axis,
                "withYAxis": with_y_axis,
                "xAxisLabel": x_axis_label,
                "xAxisProps": x_axis_props,
                "yAxisLabel": y_axis_label,
                "yAxisProps": y_axis_props,
                **kwargs,
            },
        )

    def line_chart(
        self,
        data: list,
        data_key: str,
        series: list[dict[str, Any]],
        *,
        key: Optional[str] = None,
        active_dot_props: Optional[dict[str, Any]] = None,
        connect_nulls: Optional[bool] = None,
        curve_type: Optional[str] = None,
        dot_props: Optional[dict[str, Any]] = None,
        fill_opacity: Optional[float] = None,
        gradient_stops: Optional[list[dict[str, Any]]] = None,
        grid_axis: Optional[str] = None,
        grid_color: Optional[str] = None,
        grid_props: Optional[dict[str, Any]] = None,
        legend_props: Optional[dict[str, Any]] = None,
        line_chart_props: Optional[dict[str, Any]] = None,
        line_props: Optional[dict[str, Any]] = None,
        orientation: Optional[str] = None,
        reference_lines: Optional[list[dict[str, Any]]] = None,
        right_y_axis_label: Optional[str] = None,
        right_y_axis_props: Optional[dict[str, Any]] = None,
        stroke_dasharray: Optional[str] = None,
        stroke_width: Optional[float] = None,
        text_color: Optional[str] = None,
        tick_line: Optional[str] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        type: Optional[str] = None,
        unit: Optional[str] = None,
        with_dots: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_point_labels: Optional[bool] = None,
        with_right_y_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_x_axis: Optional[bool] = None,
        with_y_axis: Optional[bool] = None,
        x_axis_label: Optional[str] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_label: Optional[str] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="linechart",
            key=key or self._new_text_id("linechart"),
            props={
                "data": data,
                "dataKey": data_key,
                "series": series,
                "activeDotProps": active_dot_props,
                "connectNulls": connect_nulls,
                "curveType": curve_type,
                "dotProps": dot_props,
                "fillOpacity": fill_opacity,
                "gradientStops": gradient_stops,
                "gridAxis": grid_axis,
                "gridColor": grid_color,
                "gridProps": grid_props,
                "legendProps": legend_props,
                "lineChartProps": line_chart_props,
                "lineProps": line_props,
                "orientation": orientation,
                "referenceLines": reference_lines,
                "rightYAxisLabel": right_y_axis_label,
                "rightYAxisProps": right_y_axis_props,
                "strokeDasharray": stroke_dasharray,
                "strokeWidth": stroke_width,
                "textColor": text_color,
                "tickLine": tick_line,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "type": type,
                "unit": unit,
                "withDots": with_dots,
                "withLegend": with_legend,
                "withPointLabels": with_point_labels,
                "withRightYAxis": with_right_y_axis,
                "withTooltip": with_tooltip,
                "withXAxis": with_x_axis,
                "withYAxis": with_y_axis,
                "xAxisLabel": x_axis_label,
                "xAxisProps": x_axis_props,
                "yAxisLabel": y_axis_label,
                "yAxisProps": y_axis_props,
                **kwargs,
            },
        )

    def composite_chart(
        self,
        data: list,
        data_key: str,
        series: list[dict[str, Any]],
        *,
        key: Optional[str] = None,
        active_dot_props: Optional[dict[str, Any]] = None,
        area_props: Optional[dict[str, Any]] = None,
        bar_props: Optional[dict[str, Any]] = None,
        children: Optional[Any] = None,
        composed_chart_props: Optional[dict[str, Any]] = None,
        connect_nulls: Optional[bool] = None,
        curve_type: Optional[str] = None,
        dot_props: Optional[dict[str, Any]] = None,
        grid_axis: Optional[str] = None,
        grid_color: Optional[str] = None,
        grid_props: Optional[dict[str, Any]] = None,
        legend_props: Optional[dict[str, Any]] = None,
        line_props: Optional[dict[str, Any]] = None,
        max_bar_width: Optional[int] = None,
        min_bar_size: Optional[int] = None,
        reference_lines: Optional[list[dict[str, Any]]] = None,
        right_y_axis_label: Optional[str] = None,
        right_y_axis_props: Optional[dict[str, Any]] = None,
        stroke_dasharray: Optional[str] = None,
        stroke_width: Optional[int] = None,
        text_color: Optional[str] = None,
        tick_line: Optional[str] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        unit: Optional[str] = None,
        with_bar_value_label: Optional[bool] = None,
        with_dots: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_point_labels: Optional[bool] = None,
        with_right_y_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_x_axis: Optional[bool] = None,
        with_y_axis: Optional[bool] = None,
        x_axis_label: Optional[str] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_label: Optional[str] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="compositechart",
            key=key or self._new_text_id("compositechart"),
            props={
                "data": data,
                "dataKey": data_key,
                "series": series,
                "activeDotProps": active_dot_props,
                "areaProps": area_props,
                "barProps": bar_props,
                "children": children,
                "composedChartProps": composed_chart_props,
                "connectNulls": connect_nulls,
                "curveType": curve_type,
                "dotProps": dot_props,
                "gridAxis": grid_axis,
                "gridColor": grid_color,
                "gridProps": grid_props,
                "legendProps": legend_props,
                "lineProps": line_props,
                "maxBarWidth": max_bar_width,
                "minBarSize": min_bar_size,
                "referenceLines": reference_lines,
                "rightYAxisLabel": right_y_axis_label,
                "rightYAxisProps": right_y_axis_props,
                "strokeDasharray": stroke_dasharray,
                "strokeWidth": stroke_width,
                "textColor": text_color,
                "tickLine": tick_line,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "unit": unit,
                "withBarValueLabel": with_bar_value_label,
                "withDots": with_dots,
                "withLegend": with_legend,
                "withPointLabels": with_point_labels,
                "withRightYAxis": with_right_y_axis,
                "withTooltip": with_tooltip,
                "withXAxis": with_x_axis,
                "withYAxis": with_y_axis,
                "xAxisLabel": x_axis_label,
                "xAxisProps": x_axis_props,
                "yAxisLabel": y_axis_label,
                "yAxisProps": y_axis_props,
                **kwargs,
            },
        )

    def donut_chart(
        self,
        data: list,
        *,
        chart_label: Optional[Union[str, int]] = None,
        end_angle: Optional[int] = None,
        key: Optional[str] = None,
        label_color: Optional[str] = None,
        labels_type: Optional[str] = None,
        padding_angle: Optional[int] = None,
        pie_chart_props: Optional[dict[str, Any]] = None,
        pie_props: Optional[dict[str, Any]] = None,
        size: Optional[int] = None,
        start_angle: Optional[int] = None,
        stroke_color: Optional[str] = None,
        stroke_width: Optional[int] = None,
        thickness: Optional[int] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_data_source: Optional[Literal["all", "segment"]] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        with_labels: Optional[bool] = None,
        with_labels_line: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="donutchart",
            key=key or self._new_text_id("donutchart"),
            props={
                "data": data,
                "chartLabel": chart_label,
                "endAngle": end_angle,
                "labelColor": label_color,
                "labelsType": labels_type,
                "paddingAngle": padding_angle,
                "pieChartProps": pie_chart_props,
                "pieProps": pie_props,
                "size": size,
                "startAngle": start_angle,
                "strokeColor": stroke_color,
                "strokeWidth": stroke_width,
                "thickness": thickness,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipDataSource": tooltip_data_source,
                "tooltipProps": tooltip_props,
                "withLabels": with_labels,
                "withLabelsLine": with_labels_line,
                "withTooltip": with_tooltip,
                **kwargs,
            },
        )

    def funnel_chart(
        self,
        data: list,
        *,
        funnel_chart_props: Optional[dict[str, Any]] = None,
        funnel_props: Optional[dict[str, Any]] = None,
        key: Optional[str] = None,
        label_color: Optional[str] = None,
        labels_position: Optional[Literal["left", "right", "inside"]] = None,
        size: Optional[int] = None,
        stroke_color: Optional[str] = None,
        stroke_width: Optional[int] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_data_source: Optional[Literal["all", "segment"]] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        value_formatter: Optional[Any] = None,
        with_labels: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="funnelchart",
            key=key or self._new_text_id("funnelchart"),
            props={
                "data": data,
                "funnelChartProps": funnel_chart_props,
                "funnelProps": funnel_props,
                "labelColor": label_color,
                "labelsPosition": labels_position,
                "size": size,
                "strokeColor": stroke_color,
                "strokeWidth": stroke_width,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipDataSource": tooltip_data_source,
                "tooltipProps": tooltip_props,
                "valueFormatter": value_formatter,
                "withLabels": with_labels,
                "withTooltip": with_tooltip,
                **kwargs,
            },
        )

    def pie_chart(
        self,
        data: list,
        *,
        end_angle: Optional[int] = None,
        key: Optional[str] = None,
        label_color: Optional[str] = None,
        labels_position: Optional[Literal["outside", "inside"]] = None,
        labels_type: Optional[Literal["value", "percent"]] = None,
        padding_angle: Optional[int] = None,
        pie_chart_props: Optional[dict[str, Any]] = None,
        pie_props: Optional[dict[str, Any]] = None,
        size: Optional[int] = None,
        start_angle: Optional[int] = None,
        stroke_color: Optional[str] = None,
        stroke_width: Optional[int] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_data_source: Optional[Literal["all", "segment"]] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        with_labels: Optional[bool] = None,
        with_labels_line: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="piechart",
            key=key or self._new_text_id("piechart"),
            props={
                "data": data,
                "endAngle": end_angle,
                "labelColor": label_color,
                "labelsPosition": labels_position,
                "labelsType": labels_type,
                "paddingAngle": padding_angle,
                "pieChartProps": pie_chart_props,
                "pieProps": pie_props,
                "size": size,
                "startAngle": start_angle,
                "strokeColor": stroke_color,
                "strokeWidth": stroke_width,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipDataSource": tooltip_data_source,
                "tooltipProps": tooltip_props,
                "withLabels": with_labels,
                "withLabelsLine": with_labels_line,
                "withTooltip": with_tooltip,
                **kwargs,
            },
        )

    def radar_chart(
        self,
        data: list,
        data_key: str,
        series: list[dict[str, Any]],
        *,
        active_dot_props: Optional[dict[str, Any]] = None,
        dot_props: Optional[dict[str, Any]] = None,
        grid_color: Optional[str] = None,
        key: Optional[str] = None,
        legend_props: Optional[dict[str, Any]] = None,
        polar_angle_axis_props: Optional[dict[str, Any]] = None,
        polar_grid_props: Optional[dict[str, Any]] = None,
        polar_radius_axis_props: Optional[dict[str, Any]] = None,
        radar_chart_props: Optional[dict[str, Any]] = None,
        radar_props: Optional[dict[str, Any]] = None,
        text_color: Optional[str] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        with_dots: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_polar_angle_axis: Optional[bool] = None,
        with_polar_grid: Optional[bool] = None,
        with_polar_radius_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="radarchart",
            key=key or self._new_text_id("radarchart"),
            props={
                "activeDotProps": active_dot_props,
                "data": data,
                "dataKey": data_key,
                "dotProps": dot_props,
                "gridColor": grid_color,
                "legendProps": legend_props,
                "polarAngleAxisProps": polar_angle_axis_props,
                "polarGridProps": polar_grid_props,
                "polarRadiusAxisProps": polar_radius_axis_props,
                "radarChartProps": radar_chart_props,
                "radarProps": radar_props,
                "series": series,
                "textColor": text_color,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "withDots": with_dots,
                "withLegend": with_legend,
                "withPolarAngleAxis": with_polar_angle_axis,
                "withPolarGrid": with_polar_grid,
                "withPolarRadiusAxis": with_polar_radius_axis,
                "withTooltip": with_tooltip,
                **kwargs,
            },
        )

    def scatter_chart(
        self,
        data: list,
        data_key: dict[str, str],
        *,
        grid_axis: Optional[str] = None,
        grid_color: Optional[str] = None,
        grid_props: Optional[dict[str, Any]] = None,
        labels: Optional[dict[str, str]] = None,
        legend_props: Optional[dict[str, Any]] = None,
        orientation: Optional[str] = None,
        point_labels: Optional[str] = None,
        reference_lines: Optional[list[dict[str, Any]]] = None,
        right_y_axis_label: Optional[str] = None,
        right_y_axis_props: Optional[dict[str, Any]] = None,
        scatter_chart_props: Optional[dict[str, Any]] = None,
        scatter_props: Optional[dict[str, Any]] = None,
        stroke_dasharray: Optional[Union[str, int]] = None,
        text_color: Optional[str] = None,
        tick_line: Optional[str] = None,
        tooltip_animation_duration: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        unit: Optional[dict[str, str]] = None,
        value_formatter: Optional[Any] = None,
        with_legend: Optional[bool] = None,
        with_right_y_axis: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_x_axis: Optional[bool] = None,
        with_y_axis: Optional[bool] = None,
        x_axis_label: Optional[str] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_label: Optional[str] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        key: Optional[str] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="scatterchart",
            key=key or self._new_text_id("scatterchart"),
            props={
                "data": data,
                "dataKey": data_key,
                "gridAxis": grid_axis,
                "gridColor": grid_color,
                "gridProps": grid_props,
                "labels": labels,
                "legendProps": legend_props,
                "orientation": orientation,
                "pointLabels": point_labels,
                "referenceLines": reference_lines,
                "rightYAxisLabel": right_y_axis_label,
                "rightYAxisProps": right_y_axis_props,
                "scatterChartProps": scatter_chart_props,
                "scatterProps": scatter_props,
                "strokeDasharray": stroke_dasharray,
                "textColor": text_color,
                "tickLine": tick_line,
                "tooltipAnimationDuration": tooltip_animation_duration,
                "tooltipProps": tooltip_props,
                "unit": unit,
                "valueFormatter": value_formatter,
                "withLegend": with_legend,
                "withRightYAxis": with_right_y_axis,
                "withTooltip": with_tooltip,
                "withXAxis": with_x_axis,
                "withYAxis": with_y_axis,
                "xAxisLabel": x_axis_label,
                "xAxisProps": x_axis_props,
                "yAxisLabel": y_axis_label,
                "yAxisProps": y_axis_props,
                **kwargs,
            },
        )

    def bubble_chart(
        self,
        data: list[dict[str, Any]],
        data_key: dict[str, str],
        range: tuple[int, int],
        *,
        color: Optional[str] = None,
        grid_color: Optional[str] = None,
        key: Optional[str] = None,
        label: Optional[str] = None,
        scatter_props: Optional[dict[str, Any]] = None,
        text_color: Optional[str] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        with_tooltip: Optional[bool] = None,
        x_axis_props: Optional[dict[str, Any]] = None,
        y_axis_props: Optional[dict[str, Any]] = None,
        z_axis_props: Optional[dict[str, Any]] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="bubblechart",
            key=key or self._new_text_id("bubblechart"),
            props={
                "data": data,
                "dataKey": data_key,
                "range": range,
                "color": color,
                "gridColor": grid_color,
                "label": label,
                "scatterProps": scatter_props,
                "textColor": text_color,
                "tooltipProps": tooltip_props,
                "withTooltip": with_tooltip,
                "xAxisProps": x_axis_props,
                "yAxisProps": y_axis_props,
                "zAxisProps": z_axis_props,
                **kwargs,
            },
        )

    def radial_bar_chart(
        self,
        data: list[dict[str, Any]],
        data_key: str,
        *,
        bar_size: Optional[int] = None,
        empty_background_color: Optional[str] = None,
        end_angle: Optional[int] = None,
        key: Optional[str] = None,
        legend_props: Optional[dict[str, Any]] = None,
        radial_bar_chart_props: Optional[dict[str, Any]] = None,
        radial_bar_props: Optional[dict[str, Any]] = None,
        start_angle: Optional[int] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        with_background: Optional[bool] = None,
        with_labels: Optional[bool] = None,
        with_legend: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="radialbarchart",
            key=key or self._new_text_id("radialbarchart"),
            props={
                "data": data,
                "dataKey": data_key,
                "barSize": bar_size,
                "emptyBackgroundColor": empty_background_color,
                "endAngle": end_angle,
                "legendProps": legend_props,
                "radialBarChartProps": radial_bar_chart_props,
                "radialBarProps": radial_bar_props,
                "startAngle": start_angle,
                "tooltipProps": tooltip_props,
                "withBackground": with_background,
                "withLabels": with_labels,
                "withLegend": with_legend,
                "withTooltip": with_tooltip,
                **kwargs,
            },
        )

    def sparkline_chart(
        self,
        data: list[Union[int, float, None]],
        *,
        area_props: Optional[dict[str, Any]] = None,
        color: Optional[str] = None,
        connect_nulls: Optional[bool] = None,
        curve_type: Optional[str] = None,
        fill_opacity: Optional[float] = None,
        key: Optional[str] = None,
        stroke_width: Optional[int] = None,
        trend_colors: Optional[dict[str, Any]] = None,
        with_gradient: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="sparkline",
            key=key or self._new_text_id("sparkline"),
            props={
                "data": data,
                "areaProps": area_props,
                "color": color,
                "connectNulls": connect_nulls,
                "curveType": curve_type,
                "fillOpacity": fill_opacity,
                "strokeWidth": stroke_width,
                "trendColors": trend_colors,
                "withGradient": with_gradient,
                **kwargs,
            },
        )

    def heatmap(
        self,
        data: dict[str, Union[int, float]],
        *,
        colors: Optional[list[str]] = None,
        domain: Optional[tuple[Union[int, float], Union[int, float]]] = None,
        end_date: Optional[Union[str, Any]] = None,
        first_day_of_week: Optional[int] = None,
        font_size: Optional[int] = None,
        gap: Optional[int] = None,
        get_rect_props: Optional[Any] = None,
        get_tooltip_label: Optional[Any] = None,
        key: Optional[str] = None,
        month_labels: Optional[list[str]] = None,
        months_labels_height: Optional[int] = None,
        rect_radius: Optional[int] = None,
        rect_size: Optional[int] = None,
        start_date: Optional[Union[str, Any]] = None,
        tooltip_props: Optional[dict[str, Any]] = None,
        weekday_labels: Optional[list[str]] = None,
        weekdays_labels_width: Optional[int] = None,
        with_month_labels: Optional[bool] = None,
        with_outside_dates: Optional[bool] = None,
        with_tooltip: Optional[bool] = None,
        with_weekday_labels: Optional[bool] = None,
        **kwargs: Any,
    ) -> "RLBuilder":
        return self._create_builder_element(  # type: ignore[return-value]
            name="heatmap",
            key=key or self._new_text_id("heatmap"),
            props={
                "data": data,
                "colors": colors,
                "domain": domain,
                "endDate": end_date,
                "firstDayOfWeek": first_day_of_week,
                "fontSize": font_size,
                "gap": gap,
                "getRectProps": get_rect_props,
                "getTooltipLabel": get_tooltip_label,
                "monthLabels": month_labels,
                "monthsLabelsHeight": months_labels_height,
                "rectRadius": rect_radius,
                "rectSize": rect_size,
                "startDate": start_date,
                "tooltipProps": tooltip_props,
                "weekdayLabels": weekday_labels,
                "weekdaysLabelsWidth": weekdays_labels_width,
                "withMonthLabels": with_month_labels,
                "withOutsideDates": with_outside_dates,
                "withTooltip": with_tooltip,
                "withWeekdayLabels": with_weekday_labels,
                **kwargs,
            },
        )
